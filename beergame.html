<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beer Game P2P (Enhanced)</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root { --primary: #2c3e50; --accent: #3498db; --danger: #e74c3c; --success: #2ecc71; --bg: #f4f7f6; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: var(--bg); margin: 0; padding: 20px; color: var(--primary); }
        .container { max-width: 1000px; margin: 0 auto; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        h1, h2, h3 { text-align: center; }
        input, button { padding: 10px; margin: 5px; border-radius: 6px; border: 1px solid #ddd; font-size: 16px; }
        button { background: var(--accent); color: white; border: none; cursor: pointer; transition: 0.3s; }
        button:hover { background: #2980b9; }
        button:disabled { background: #bdc3c7; cursor: not-allowed; }
        
        /* Instructions Panel */
        .instructions { background: #f8f9fa; border-left: 5px solid var(--accent); padding: 15px; margin: 20px 0; text-align: left; }
        .instructions h4 { margin-top: 0; }
        .instructions li { margin-bottom: 5px; font-size: 14px; }

        .game-board { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 20px; }
        .chain-node { background: white; border: 1px solid #ccc; padding: 10px; border-radius: 8px; text-align: center; font-size: 14px; position: relative; }
        .chain-node.active { border-color: var(--accent); box-shadow: 0 0 8px rgba(52, 152, 219, 0.3); }
        
        .status-bar { display: flex; justify-content: space-between; background: #34495e; color: white; padding: 10px; border-radius: 8px; margin-bottom: 20px; }
        .timer { font-weight: bold; color: #f1c40f; }
        .timer.urgent { color: #e74c3c; animation: pulse 1s infinite; }
        
        .input-area { text-align: center; margin: 20px 0; padding: 20px; background: #e8f6f3; border-radius: 8px; }
        .live-chart-container { margin: 20px 0; padding: 10px; border: 1px solid #eee; border-radius: 8px; }
        
        .hidden-info { color: #ccc; font-style: italic; }
        .waiting-msg { color: #e67e22; font-weight: bold; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        @media (max-width: 768px) { .game-board { grid-template-columns: 1fr; } }
    </style>
</head>
<body>

<div id="app" class="container">
    <h1>üçª The Beer Game</h1>

    <div v-if="state.phase === 'LOBBY'" style="text-align: center;">
        
        <div class="instructions">
            <h4>üìñ How to Play</h4>
            <ul>
                <li><strong>Goal:</strong> Minimize total costs by managing inventory efficiently.</li>
                <li><strong>The Supply Chain:</strong> Factory ‚ûú Distributor ‚ûú Wholesaler ‚ûú Retailer ‚ûú Customer.</li>
                <li><strong>Costs:</strong> 
                    <span style="color: green">Holding Inventory: $0.50</span> / unit / week. 
                    <span style="color: red">Backlog (Out of Stock): $1.00</span> / unit / week.
                </li>
                <li><strong>Delays (Lead Time):</strong>
                    Orders take <strong>1 week</strong> to reach upstream.
                    Shipments take <strong>1 week</strong> to reach downstream.
                    (Total round-trip effect is approx. 2 weeks).
                </li>
            </ul>
        </div>

        <p>Serverless Multiplayer. No login required.</p>
        <div style="margin: 20px;">
            <input v-model="roomCode" placeholder="Enter Room Code (e.g. Room1)" @keyup.enter="joinRoom">
            <p style="font-size: 12px; color: #666;">Tip: End code with <b>-open</b> for transparent mode (e.g., <code>demo-open</code>)</p>
        </div>
        <div>
            <button @click="createRoom" :disabled="loading">I am Host (Create)</button>
            <button @click="joinRoom" :disabled="loading">I am Player (Join)</button>
        </div>
        <p v-if="loading">Connecting to network...</p>
        <p v-if="error" style="color: var(--danger)">Error: {{ error }}</p>
    </div>

    <div v-if="state.phase === 'WAITING'">
        <h3>Room: {{ roomCode }} | Waiting for Players</h3>
        <p>Connected: {{ connectedPlayers }} / 4</p>
        <div v-if="isHost">
            <p>Waiting for others. Empty slots will be filled by CPU Bots.</p>
            <button @click="startGame" :disabled="connectedPlayers < 1">Start Game</button>
        </div>
        <div v-else>
            <p>Waiting for host to start...</p>
        </div>
        <div class="role-card">
            <h4>Players:</h4>
            <ul>
                <li v-for="p in playerList" :key="p.id">
                    {{ p.id === myId ? '(You) ' : '' }} 
                    {{ p.role ? roleNames[p.role] : 'Waiting...' }}
                </li>
            </ul>
        </div>
    </div>

    <div v-if="state.phase === 'PLAYING' || state.phase === 'ENDED'">
        <div class="status-bar">
            <span>Week {{ gameState.week }}</span>
            <span>Role: {{ myRoleLabel }}</span>
            <span v-if="state.phase === 'PLAYING'">
                Time: <span class="timer" :class="{urgent: timer < 10}">{{ timer }}s</span>
            </span>
            <span v-else style="color: var(--success)">GAME OVER</span>
        </div>

        <div class="game-board">
            <div v-for="role in rolesOrder" :key="role" 
                 class="chain-node" 
                 :class="{ 'active': role === myRole, 'my-role': role === myRole }">
                <h3>{{ roleNames[role] }} <span v-if="gameState.players[role].isBot" style="font-size:0.8em; color:#888">(Bot)</span></h3>
                
                <div v-if="canSee(role)">
                    <p>Inventory: <strong>{{ gameState.players[role].inventory }}</strong></p>
                    <p>Backlog: <strong style="color:var(--danger)">{{ gameState.players[role].backlog }}</strong></p>
                    <p>Last Order: {{ gameState.players[role].lastOrder }}</p>
                    <hr>
                    <p>Incoming Demand: {{ getIncomingDemand(role) }}</p>
                    <p>Incoming Delivery: {{ gameState.players[role].incomingShipment }}</p>
                </div>
                <div v-else class="hidden-info">
                    <p>[Hidden]</p>
                    <p>???</p>
                </div>
                
                <div v-if="state.phase === 'PLAYING' && hasPlayerSubmitted(role)" 
                     style="position:absolute; top:5px; right:5px; color:var(--success); font-weight:bold;">
                    ‚úî Ready
                </div>
            </div>
        </div>

        <div v-if="state.phase === 'PLAYING' && !imDead" class="input-area">
            <div v-if="isProcessing">
                <h3 style="color: var(--accent)">Calculating Next Week...</h3>
            </div>
            <div v-else-if="hasSubmitted">
                <h3>Order Submitted: {{ myOrderVal }}</h3>
                <p class="waiting-msg">Waiting for other players...</p>
            </div>
            <div v-else>
                <h3>Place Your Order</h3>
                <p>Decide how much to order from your supplier.</p>
                <input type="number" v-model.number="inputOrder" min="0" placeholder="Qty">
                <button @click="submitOrder">Submit Order</button>
            </div>
        </div>
        
        <div v-if="imDead" class="input-area" style="color: var(--danger)">
            <h3>Connection Lost / Timeout</h3>
            <p>CPU has taken over.</p>
            <button @click="reconnectControl">Reclaim Control</button>
        </div>

        <div v-if="state.phase === 'PLAYING'" class="live-chart-container">
            <h4>üìä Your Performance Trend</h4>
            <div style="height: 800px; position: relative;">
                <canvas id="liveChart"></canvas>
            </div>
        </div>

        <div v-if="state.phase === 'ENDED'" class="chart-container">
            <h3>Game Results</h3>
            <canvas id="orderChart"></canvas>
            <canvas id="costChart" style="margin-top:40px"></canvas>
            <button @click="downloadData" style="margin-top:20px">Download CSV</button>
        </div>
    </div>
</div>

<script>
const { createApp, reactive, ref, computed, nextTick, watch } = Vue;

const ROLES = ['Retailer', 'Wholesaler', 'Distributor', 'Factory'];
const ROLE_NAMES = { 'Retailer': 'Retailer', 'Wholesaler': 'Wholesaler', 'Distributor': 'Distributor', 'Factory': 'Factory' };
const INITIAL_INV = 12;
const ROUND_TIME = 35; 
const TOTAL_WEEKS = 25; 

createApp({
    setup() {
        const state = reactive({ phase: 'LOBBY' });
        const roomCode = ref('');
        const myId = ref('');
        const isHost = ref(false);
        const loading = ref(false);
        const error = ref('');
        const playerList = ref([]); 
        const myRole = ref('');
        const timer = ref(ROUND_TIME);
        const isProcessing = ref(false);

        const gameState = reactive({
            week: 1,
            isOpenInfo: false,
            players: {}, 
            shipments: [], 
            orderStatus: {} 
        });

        const inputOrder = ref(0);
        const hasSubmitted = ref(false);
        const myOrderVal = ref(0);
        const imDead = ref(false);

        let peer = null;
        let conns = [];
        let hostConn = null;
        let timerInterval = null;
        let liveChartInstance = null; // Store chart instance

        const rolesOrder = computed(() => ROLES);
        const roleNames = computed(() => ROLE_NAMES);
        const connectedPlayers = computed(() => playerList.value.length);
        const myRoleLabel = computed(() => ROLE_NAMES[myRole.value] || 'Spectator');

        /* --- P2P Networking --- */
        const initPeer = (id) => {
            return new Promise((resolve, reject) => {
                const p = new Peer(id);
                p.on('open', (id) => resolve(p));
                p.on('error', (err) => reject(err));
            });
        };

        const createRoom = async () => {
            if (!roomCode.value) return;
            loading.value = true;
            const roomId = `bg-game-${roomCode.value}`;
            try {
                peer = await initPeer(roomId);
                myId.value = roomId;
                isHost.value = true;
                state.phase = 'WAITING';
                playerList.value.push({ id: 'HOST', role: null });
                peer.on('connection', handleHostConnection);
                if (roomCode.value.endsWith('-open')) gameState.isOpenInfo = true;
            } catch (err) {
                error.value = "Room ID taken or network error.";
                console.error(err);
            } finally { loading.value = false; }
        };

        const joinRoom = async () => {
            if (!roomCode.value) return;
            loading.value = true;
            try {
                const clientId = 'bg-player-' + Math.random().toString(36).substr(2, 9);
                peer = await initPeer(clientId);
                myId.value = clientId;
                hostConn = peer.connect(`bg-game-${roomCode.value}`);
                hostConn.on('open', () => {
                    isHost.value = false;
                    state.phase = 'WAITING';
                    const savedRole = localStorage.getItem(`bg_role_${roomCode.value}`);
                    hostConn.send({ type: 'JOIN', savedRole: savedRole });
                });
                hostConn.on('data', handleClientData);
                hostConn.on('close', () => { error.value = "Disconnected from Host"; });
            } catch (err) {
                error.value = "Could not connect.";
            } finally { loading.value = false; }
        };

        /* --- Host Logic --- */
        const handleHostConnection = (conn) => {
            conns.push(conn);
            conn.on('data', (data) => {
                if (data.type === 'JOIN') {
                    let existingRole = null;
                    if (data.savedRole && state.phase === 'PLAYING') {
                        if (gameState.players[data.savedRole] && gameState.players[data.savedRole].isBot) {
                            existingRole = data.savedRole;
                            gameState.players[existingRole].isBot = false;
                            gameState.players[existingRole].id = conn.peer;
                        }
                    }
                    if (!existingRole) {
                        if (state.phase === 'WAITING') {
                            playerList.value.push({ id: conn.peer, role: null });
                            broadcastLobby();
                        } else {
                            conn.send({ type: 'ERROR', msg: 'Game already started' });
                        }
                    } else {
                        conn.send({ type: 'RECONNECT_SUCCESS', role: existingRole, state: gameState });
                    }
                }
                else if (data.type === 'ORDER') handleOrderReceived(data.role, data.amount);
                else if (data.type === 'RECLAIM') {
                     if (gameState.players[data.role]) {
                         gameState.players[data.role].isBot = false;
                         broadcastState();
                     }
                }
            });
            conn.on('close', () => {
                const idx = playerList.value.findIndex(p => p.id === conn.peer);
                if (idx !== -1 && state.phase === 'WAITING') {
                    playerList.value.splice(idx, 1);
                    broadcastLobby();
                } else if (state.phase === 'PLAYING') {
                    for (let r in gameState.players) {
                        if (gameState.players[r].id === conn.peer) gameState.players[r].isBot = true;
                    }
                    checkRoundCompletion();
                }
            });
        };

        /* --- Client Logic --- */
        const handleClientData = (data) => {
            if (data.type === 'LOBBY_UPDATE') {
                playerList.value = data.players;
            } else if (data.type === 'GAME_START') {
                myRole.value = data.role;
                Object.assign(gameState, data.state);
                state.phase = 'PLAYING';
                localStorage.setItem(`bg_role_${roomCode.value}`, myRole.value);
                nextTick(updateLiveChart);
            } else if (data.type === 'STATE_UPDATE') {
                const weekChanged = data.state.week > gameState.week;
                if (weekChanged) {
                    hasSubmitted.value = false;
                    inputOrder.value = 0;
                }
                Object.assign(gameState, data.state);
                isProcessing.value = false;
                if(weekChanged) nextTick(updateLiveChart);
            } else if (data.type === 'TIMER_UPDATE') {
                timer.value = data.time;
            } else if (data.type === 'GAME_OVER') {
                Object.assign(gameState, data.state);
                state.phase = 'ENDED';
                nextTick(renderEndCharts);
            } else if (data.type === 'RECONNECT_SUCCESS') {
                myRole.value = data.role;
                Object.assign(gameState, data.state);
                state.phase = 'PLAYING';
                imDead.value = false;
                nextTick(updateLiveChart);
            }
        };

        const broadcastLobby = () => conns.forEach(c => c.send({ type: 'LOBBY_UPDATE', players: playerList.value }));
        const broadcastState = () => conns.forEach(c => c.send({ type: 'STATE_UPDATE', state: gameState }));

        /* --- Game Core --- */
        const startGame = () => {
            const shuffledRoles = [...ROLES].sort(() => 0.5 - Math.random());
            const playersMap = {};
            playerList.value.forEach((p, i) => { if (i < 4) p.role = shuffledRoles[i]; });

            for (let i = 0; i < 4; i++) {
                const role = shuffledRoles[i];
                const player = playerList.value.find(p => p.role === role);
                playersMap[role] = {
                    id: player ? player.id : 'BOT',
                    isBot: !player,
                    role: role,
                    inventory: INITIAL_INV,
                    backlog: 0,
                    lastOrder: 4,
                    incomingShipment: 0,
                    history: []
                };
                if (player && player.id === 'HOST') myRole.value = role;
            }
            
            gameState.players = playersMap;
            gameState.week = 1;
            gameState.orderStatus = {};
            gameState.shipments = [];
            
            conns.forEach(c => {
                const p = playerList.value.find(pl => pl.id === c.peer);
                if (p && p.role) c.send({ type: 'GAME_START', role: p.role, state: gameState });
            });
            state.phase = 'PLAYING';
            nextTick(updateLiveChart);
            startTimer();
        };

        const startTimer = () => {
            if (timerInterval) clearInterval(timerInterval);
            timer.value = ROUND_TIME;
            
            timerInterval = setInterval(() => {
                timer.value--;
                if (isHost.value) conns.forEach(c => c.send({ type: 'TIMER_UPDATE', time: timer.value }));
                if (timer.value <= 0) {
                    clearInterval(timerInterval);
                    if (isHost.value) processRound();
                }
            }, 1000);
        };

        const submitOrder = () => {
            if (inputOrder.value < 0 || inputOrder.value === '') return;
            hasSubmitted.value = true;
            myOrderVal.value = inputOrder.value;
            
            if (isHost.value) {
                handleOrderReceived(myRole.value, inputOrder.value);
            } else {
                hostConn.send({ type: 'ORDER', role: myRole.value, amount: inputOrder.value });
            }
        };

        const handleOrderReceived = (role, amount) => {
            if (!isHost.value) return;
            gameState.orderStatus[role] = amount;
            broadcastState();
            checkRoundCompletion();
        };

        const checkRoundCompletion = () => {
            const allHumansDone = ROLES.every(r => {
                const p = gameState.players[r];
                return p.isBot || gameState.orderStatus[r] !== undefined;
            });
            
            if (allHumansDone && !isProcessing.value) {
                isProcessing.value = true;
                clearInterval(timerInterval);
                setTimeout(() => {
                    processRound();
                    isProcessing.value = false; 
                }, 1000);
            }
        };

        // --- DEMAND LOGIC IS HERE ---
        const getDemand = (week) => (week <= 4 ? 4 : 8);

        const getDownstream = (role) => {
            const idx = ROLES.indexOf(role);
            return idx > 0 ? ROLES[idx - 1] : null;
        };

        const processRound = () => {
            const currentWeek = gameState.week;
            const orders = {};

            ROLES.forEach(role => {
                const p = gameState.players[role];
                let orderQty = 0;
                
                if (p.isBot) {
                    const incomingDemand = role === 'Retailer' ? getDemand(currentWeek) : (gameState.players[getDownstream(role)]?.lastOrder || 4);
                    let correction = 0;
                    if (p.inventory < 4) correction = 2;
                    if (p.backlog > 0) correction = p.backlog;
                    orderQty = incomingDemand + correction;
                } else {
                    if (gameState.orderStatus[role] !== undefined) orderQty = gameState.orderStatus[role];
                    else orderQty = p.lastOrder;
                }
                orders[role] = orderQty;
                p.lastOrder = orderQty;
            });

            const shipmentsSent = {}; 
            ROLES.slice().reverse().forEach(role => {
                const p = gameState.players[role];
                let currentDemand = role === 'Retailer' ? getDemand(currentWeek) : gameState.players[getDownstream(role)].lastOrder;
                const totalDemand = currentDemand + p.backlog;
                
                const incoming = gameState.shipments.find(s => s.to === role && s.weeksLeft === 0);
                const arrivedQty = incoming ? incoming.amount : 0;
                
                p.incomingShipment = arrivedQty;
                const available = p.inventory + arrivedQty;
                
                let shipped = 0;
                if (available >= totalDemand) {
                    shipped = totalDemand;
                    p.inventory = available - totalDemand;
                    p.backlog = 0;
                } else {
                    shipped = available;
                    p.inventory = 0;
                    p.backlog = totalDemand - available;
                }
                shipmentsSent[role] = shipped;

                p.history.push({
                    week: currentWeek,
                    inventory: p.inventory,
                    backlog: p.backlog,
                    order: orders[role],
                    demand: currentDemand,
                    cost: p.inventory * 0.5 + p.backlog * 1
                });
            });

            gameState.shipments = gameState.shipments.filter(s => s.weeksLeft > 0);
            gameState.shipments.forEach(s => s.weeksLeft--);

            ROLES.forEach(role => {
                const amount = shipmentsSent[role];
                if (role === 'Factory') {
                    gameState.shipments.push({ to: 'Distributor', amount: amount, weeksLeft: 1 });
                    gameState.shipments.push({ to: 'Factory', amount: orders['Factory'], weeksLeft: 1 });
                } else if (role !== 'Retailer') {
                    const down = getDownstream(role);
                    gameState.shipments.push({ to: down, amount: amount, weeksLeft: 1 });
                }
            });

            gameState.week++;
            gameState.orderStatus = {};
            hasSubmitted.value = false;
            inputOrder.value = 0;

            if (gameState.week > TOTAL_WEEKS) {
                endGame();
            } else {
                broadcastState();
                nextTick(updateLiveChart);
                startTimer();
            }
        };

        const endGame = () => {
            state.phase = 'ENDED';
            conns.forEach(c => c.send({ type: 'GAME_OVER', state: gameState }));
            nextTick(renderEndCharts);
        };

        const reconnectControl = () => {
             imDead.value = false;
             if (!isHost.value) hostConn.send({ type: 'RECLAIM', role: myRole.value });
             else gameState.players[myRole.value].isBot = false;
        };

        const canSee = (role) => gameState.isOpenInfo || role === myRole.value;
        const hasPlayerSubmitted = (role) => gameState.orderStatus[role] !== undefined;

        const getIncomingDemand = (role) => {
            if (state.phase !== 'PLAYING') return 0;
            if (role === 'Retailer') return getDemand(gameState.week);
            const down = getDownstream(role);
            if (gameState.isOpenInfo) return gameState.players[down].lastOrder;
            return gameState.players[down]?.lastOrder || '???';
        };

        /* --- Charts --- */
        
        // 1. Live Chart (During Game)
        const updateLiveChart = () => {
            const ctx = document.getElementById('liveChart');
            if (!ctx || !myRole.value) return;

            const myData = gameState.players[myRole.value].history;
            const labels = myData.map(h => 'W' + h.week);
            
            // Prepare Data
            const inventoryData = myData.map(h => h.inventory);
            const backlogData = myData.map(h => h.backlog); // Show as positive for comparison or neg? Let's keep separate lines
            const orderData = myData.map(h => h.order);

            if (liveChartInstance) liveChartInstance.destroy();

            liveChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'My Inventory', data: inventoryData, borderColor: '#2ecc71', tension: 0.1 },
                        { label: 'My Backlog', data: backlogData, borderColor: '#e74c3c', tension: 0.1 },
                        { label: 'My Orders', data: orderData, borderColor: '#3498db', borderDash: [5,5], tension: 0.1 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: true, text: `Live Performance: ${ROLE_NAMES[myRole.value]}` }
                    },
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: 'Units' } },
                        x: { title: { display: true, text: 'Week' } }
                    }
                }
            });
        };

        // 2. End Game Charts
        const renderEndCharts = () => {
            const ctxOrder = document.getElementById('orderChart');
            const ctxCost = document.getElementById('costChart');
            if (!ctxOrder || !ctxCost) return;

            const weeks = Array.from({length: TOTAL_WEEKS}, (_, i) => i + 1);
            
            // Order Chart
            const datasetsOrder = ROLES.map((role, i) => {
                return {
                    label: roleNames.value[role],
                    data: gameState.players[role].history.map(h => h.order),
                    borderColor: ['#e74c3c', '#3498db', '#f1c40f', '#2ecc71'][i],
                    fill: false,
                    tension: 0.2
                };
            });
            // Add Demand Reference
            datasetsOrder.push({
                label: 'Customer Demand',
                data: weeks.map(w => getDemand(w)),
                borderColor: '#000',
                borderDash: [5, 5],
                borderWidth: 2,
                pointRadius: 0
            });

            new Chart(ctxOrder, {
                type: 'line',
                data: { labels: weeks, datasets: datasetsOrder },
                options: { 
                    responsive: true, 
                    plugins: {
                        title: { display: true, text: 'Order Quantity Variation (Bullwhip Effect)', font: {size: 18} }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Week Number' } },
                        y: { title: { display: true, text: 'Order Quantity (Units)' } }
                    }
                }
            });

            // Cost Chart
            const datasetsCost = ROLES.map((role, i) => {
                return {
                    label: roleNames.value[role],
                    data: gameState.players[role].history.reduce((acc, curr, idx) => {
                        const prev = idx > 0 ? acc[idx-1] : 0;
                        acc.push(prev + curr.cost);
                        return acc;
                    }, []),
                    borderColor: ['#e74c3c', '#3498db', '#f1c40f', '#2ecc71'][i],
                    fill: false
                };
            });

            new Chart(ctxCost, {
                type: 'line',
                data: { labels: weeks, datasets: datasetsCost },
                options: { 
                    responsive: true, 
                    plugins: {
                        title: { display: true, text: 'Cumulative Supply Chain Costs', font: {size: 18} }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Week Number' } },
                        y: { title: { display: true, text: 'Total Cost ($)' } }
                    }
                }
            });
        };

        const downloadData = () => {
            let csv = "Week,Role,Inventory,Backlog,Order,Cost\n";
            ROLES.forEach(role => {
                gameState.players[role].history.forEach(h => {
                    csv += `${h.week},${role},${h.inventory},${h.backlog},${h.order},${h.cost}\n`;
                });
            });
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `beergame_results_${roomCode.value}.csv`;
            a.click();
        };

        return {
            state, roomCode, myId, isHost, loading, error, playerList, myRole, timer, gameState,
            inputOrder, hasSubmitted, myOrderVal, imDead, isProcessing,
            rolesOrder, roleNames, connectedPlayers, myRoleLabel,
            createRoom, joinRoom, startGame, submitOrder, reconnectControl, canSee, getIncomingDemand,
            hasPlayerSubmitted, downloadData
        };
    }
}).mount('#app');
</script>
</body>
</html>

