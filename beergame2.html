<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Beer Game</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root { --primary: #2c3e50; --accent: #3498db; --danger: #e74c3c; --bg: #f4f7f6; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: var(--bg); margin: 0; padding: 20px; color: var(--primary); }
        .container { max-width: 1000px; margin: 0 auto; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        h1, h2, h3 { text-align: center; }
        input, button { padding: 10px; margin: 5px; border-radius: 6px; border: 1px solid #ddd; font-size: 16px; }
        button { background: var(--accent); color: white; border: none; cursor: pointer; transition: 0.3s; }
        button:hover { background: #2980b9; }
        button:disabled { background: #bdc3c7; cursor: not-allowed; }
        .role-card { border: 1px solid #eee; padding: 15px; margin: 10px 0; border-radius: 8px; background: #fafafa; }
        .my-role { border: 2px solid var(--accent); background: #eef7fb; }
        .game-board { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 20px; }
        .chain-node { background: white; border: 1px solid #ccc; padding: 10px; border-radius: 8px; text-align: center; font-size: 14px; }
        .chain-node.active { border-color: var(--accent); box-shadow: 0 0 8px rgba(52, 152, 219, 0.3); }
        .status-bar { display: flex; justify-content: space-between; background: #34495e; color: white; padding: 10px; border-radius: 8px; margin-bottom: 20px; }
        .timer { font-weight: bold; color: #f1c40f; }
        .log-area { height: 150px; overflow-y: auto; background: #f8f9fa; border: 1px solid #ddd; padding: 10px; font-size: 12px; margin-top: 20px; }
        .input-area { text-align: center; margin: 20px 0; padding: 20px; background: #e8f6f3; border-radius: 8px; }
        .chart-container { margin-top: 30px; }
        .hidden-info { color: #ccc; font-style: italic; }
        /* å“åº”å¼ */
        @media (max-width: 768px) { .game-board { grid-template-columns: 1fr; } }
    </style>
</head>
<body>

<div id="app" class="container">
    <h1>ğŸ» The Beer Game (P2Pç‰ˆ)</h1>

    <div v-if="state.phase === 'LOBBY'" style="text-align: center;">
        <p>æ— éœ€æœåŠ¡å™¨ï¼Œå•ç½‘é¡µå¤šäººè”æœºã€‚æ¨èä½¿ç”¨ç”µè„‘ç«¯ Chrome/Edge æµè§ˆå™¨ã€‚</p>
        <div style="margin: 20px;">
            <input v-model="roomCode" placeholder="è¾“å…¥æˆ¿é—´ç  (ä¾‹å¦‚: room1)" @keyup.enter="joinRoom">
            <p style="font-size: 12px; color: #666;">æç¤ºï¼šæˆ¿é—´ç ä»¥ <b>-open</b> ç»“å°¾å¼€å¯å…¨é€æ˜æ¨¡å¼ (å¦‚: <code>test-open</code>)</p>
        </div>
        <div>
            <button @click="createRoom" :disabled="loading">æˆ‘æ˜¯ç»„é•¿ (åˆ›å»ºæˆ¿é—´)</button>
            <button @click="joinRoom" :disabled="loading">æˆ‘æ˜¯ç»„å‘˜ (åŠ å…¥æˆ¿é—´)</button>
        </div>
        <p v-if="loading">æ­£åœ¨è¿æ¥ P2P ç½‘ç»œ...</p>
        <p v-if="error" style="color: var(--danger)">{{ error }}</p>
    </div>

    <div v-if="state.phase === 'WAITING'">
        <h3>æˆ¿é—´: {{ roomCode }} | è§’è‰²åˆ†é…ä¸­...</h3>
        <p>å½“å‰è¿æ¥äººæ•°: {{ connectedPlayers }} / 4</p>
        <div v-if="isHost">
            <p>ç­‰å¾…å…¶ä»–ç©å®¶åŠ å…¥ã€‚å¦‚æœäººæ•°ä¸è¶³ï¼Œå‰©ä½™ä½ç½®å°†ç”±ç”µè„‘(Bot)ä»£æ›¿ã€‚</p>
            <button @click="startGame" :disabled="connectedPlayers < 1">å¼€å§‹æ¸¸æˆ</button>
        </div>
        <div v-else>
            <p>ç­‰å¾…ç»„é•¿å¼€å§‹æ¸¸æˆ...</p>
        </div>
        <div class="role-card">
            <h4>å·²è¿æ¥ç©å®¶:</h4>
            <ul>
                <li v-for="p in playerList" :key="p.id">{{ p.id === myId ? '(æˆ‘) ' : '' }} {{ p.role || 'ç­‰å¾…åˆ†é…...' }}</li>
            </ul>
        </div>
    </div>

    <div v-if="state.phase === 'PLAYING' || state.phase === 'ENDED'">
        <div class="status-bar">
            <span>ç¬¬ {{ gameState.week }} å‘¨</span>
            <span>è§’è‰²: {{ myRoleLabel }}</span>
            <span v-if="state.phase === 'PLAYING'">å‰©ä½™æ—¶é—´: <span class="timer">{{ timer }}s</span></span>
            <span v-else style="color: #2ecc71">æ¸¸æˆç»“æŸ</span>
        </div>

        <div class="game-board">
            <div v-for="role in rolesOrder" :key="role" 
                 class="chain-node" 
                 :class="{ 'active': role === myRole, 'my-role': role === myRole }">
                <h3>{{ roleNames[role] }} <span v-if="gameState.players[role].isBot">(Bot)</span></h3>
                
                <div v-if="canSee(role)">
                    <p>åº“å­˜: <strong>{{ gameState.players[role].inventory }}</strong></p>
                    <p>æ¬ è´§: <strong style="color:var(--danger)">{{ gameState.players[role].backlog }}</strong></p>
                    <p>ä¸Šå‘¨è®¢å•: {{ gameState.players[role].lastOrder }}</p>
                    <hr>
                    <p>æœ¬å‘¨éœ€æ±‚: {{ getIncomingDemand(role) }}</p>
                    <p>æœ¬å‘¨æ”¶è´§: {{ gameState.players[role].incomingShipment }}</p>
                </div>
                <div v-else class="hidden-info">
                    <p>[ä¿¡æ¯éšè—]</p>
                    <p>???</p>
                </div>
            </div>
        </div>

        <div v-if="state.phase === 'PLAYING' && !imDead" class="input-area">
            <div v-if="hasSubmitted">
                <h3>å·²æäº¤è®¢å•: {{ myOrderVal }}</h3>
                <p>ç­‰å¾…å…¶ä»–ç©å®¶...</p>
            </div>
            <div v-else>
                <h3>è¯·ä¸‹è¾¾è®¢å•</h3>
                <p>å½“å‰åº“å­˜æƒ…å†µå¦‚ä¸Šï¼Œä½ éœ€è¦å‘ä½ çš„ä¸Šæ¸¸è®¢è´§ã€‚</p>
                <input type="number" v-model.number="inputOrder" min="0" placeholder="è¾“å…¥è®¢è´§é‡">
                <button @click="submitOrder">æäº¤è®¢å•</button>
            </div>
        </div>
        <div v-if="imDead" class="input-area" style="color: red">
            <h3>ä½ å·²ç”±ç”µè„‘æ¥ç®¡</h3>
            <p>æ£€æµ‹åˆ°æ‰çº¿æˆ–è¶…æ—¶ï¼Œç³»ç»Ÿå·²è‡ªåŠ¨æ‰˜ç®¡ã€‚</p>
            <button @click="reconnectControl">é‡æ–°æ¥ç®¡</button>
        </div>

        <div v-if="state.phase === 'ENDED'" class="chart-container">
            <h3>æ¸¸æˆç»Ÿè®¡æŠ¥è¡¨</h3>
            <canvas id="orderChart"></canvas>
            <canvas id="costChart" style="margin-top:20px"></canvas>
            <button @click="downloadData">ä¸‹è½½æ•°æ®(CSV)</button>
        </div>
    </div>
</div>

<script>
const { createApp, reactive, ref, computed, onMounted, nextTick } = Vue;

/* --- æ¸¸æˆé…ç½®å¸¸é‡ --- */
const ROLES = ['Retailer', 'Wholesaler', 'Distributor', 'Factory'];
const ROLE_NAMES = { 'Retailer': 'é›¶å”®å•†', 'Wholesaler': 'æ‰¹å‘å•†', 'Distributor': 'åˆ†é”€å•†', 'Factory': 'å·¥å‚' };
const INITIAL_INV = 12;
const ROUND_TIME = 30; // æ¯è½®ç§’æ•°
const TOTAL_WEEKS = 25; // æ€»å‘¨æ•° (ç®€å•èµ·è§)

/* --- åº”ç”¨é€»è¾‘ --- */
createApp({
    setup() {
        // --- å“åº”å¼çŠ¶æ€ ---
        const state = reactive({
            phase: 'LOBBY', // LOBBY, WAITING, PLAYING, ENDED
        });
        const roomCode = ref('');
        const myId = ref('');
        const isHost = ref(false);
        const loading = ref(false);
        const error = ref('');
        const playerList = ref([]); // [{id, role}]
        const myRole = ref('');
        const timer = ref(ROUND_TIME);
        
        // æ¸¸æˆæ ¸å¿ƒæ•°æ® (Hostç»´æŠ¤ï¼ŒClientåŒæ­¥)
        const gameState = reactive({
            week: 1,
            isOpenInfo: false, // æ˜¯å¦é€æ˜
            players: {}, // Key: Role, Value: { id, isBot, inventory, backlog, lastOrder, history: [] }
            shipments: [], // åœ¨é€”è´§ç‰© { from, to, amount, weeksLeft } (ç®€åŒ–ï¼šç›´æ¥ä¸‹ä¸€è½®åˆ°è´§)
            orderStatus: {} // è®°å½•å½“è½®è°æäº¤äº† { Retailer: true/false }
        });

        // ç©å®¶è¾“å…¥
        const inputOrder = ref(0);
        const hasSubmitted = ref(false);
        const myOrderVal = ref(0);
        const imDead = ref(false); // æœ¬åœ°æ ‡è®°æ˜¯å¦è¢«æ‰˜ç®¡

        // PeerJS å¯¹è±¡
        let peer = null;
        let conns = []; // Host ç”¨: å­˜å‚¨æ‰€æœ‰å®¢æˆ·ç«¯è¿æ¥
        let hostConn = null; // Client ç”¨: å­˜å‚¨ä¸ Host çš„è¿æ¥
        let timerInterval = null;

        // --- è®¡ç®—å±æ€§ ---
        const rolesOrder = computed(() => ROLES);
        const roleNames = computed(() => ROLE_NAMES);
        const connectedPlayers = computed(() => playerList.value.length);
        const myRoleLabel = computed(() => ROLE_NAMES[myRole.value] || 'è§‚ä¼—/æœªçŸ¥');

        // --- P2P ç½‘ç»œé€»è¾‘ ---
        
        // åˆå§‹åŒ– Peer
        const initPeer = (id) => {
            return new Promise((resolve, reject) => {
                // ä½¿ç”¨é»˜è®¤çš„ PeerJS Cloud Server
                const p = new Peer(id, { debug: 1 });
                p.on('open', (id) => resolve(p));
                p.on('error', (err) => reject(err));
            });
        };

        // åˆ›å»ºæˆ¿é—´ (Host)
        const createRoom = async () => {
            if (!roomCode.value) return;
            loading.value = true;
            const roomId = `bg-game-${roomCode.value}`; // å¢åŠ å‰ç¼€é¿å…å†²çª
            
            try {
                peer = await initPeer(roomId);
                myId.value = roomId;
                isHost.value = true;
                state.phase = 'WAITING';
                
                // è‡ªå·±ä¹Ÿç®—ä¸€ä¸ªç©å®¶
                playerList.value.push({ id: 'HOST', role: null });

                // ç›‘å¬è¿æ¥
                peer.on('connection', (conn) => {
                    handleHostConnection(conn);
                });

                // åˆå§‹åŒ–æ¸¸æˆæ¨¡å¼
                if (roomCode.value.endsWith('-open')) {
                    gameState.isOpenInfo = true;
                }

            } catch (err) {
                error.value = "æˆ¿é—´å·å·²è¢«å ç”¨æˆ–ç½‘ç»œé”™è¯¯ï¼Œè¯·æ¢ä¸€ä¸ªã€‚";
                console.error(err);
            } finally {
                loading.value = false;
            }
        };

        // åŠ å…¥æˆ¿é—´ (Client)
        const joinRoom = async () => {
            if (!roomCode.value) return;
            loading.value = true;
            
            try {
                // å®¢æˆ·ç«¯éšæœºç”ŸæˆID
                const clientId = 'bg-player-' + Math.random().toString(36).substr(2, 9);
                peer = await initPeer(clientId);
                myId.value = clientId;

                const hostId = `bg-game-${roomCode.value}`;
                hostConn = peer.connect(hostId);

                hostConn.on('open', () => {
                    isHost.value = false;
                    state.phase = 'WAITING';
                    // å°è¯•é‡è¿é€»è¾‘ï¼šæ£€æŸ¥æœ¬åœ°å­˜å‚¨
                    const savedRole = localStorage.getItem(`bg_role_${roomCode.value}`);
                    hostConn.send({ type: 'JOIN', savedRole: savedRole });
                });

                hostConn.on('data', (data) => {
                    handleClientData(data);
                });

                hostConn.on('close', () => {
                    error.value = "ä¸æˆ¿ä¸»æ–­å¼€è¿æ¥";
                });

            } catch (err) {
                error.value = "æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨";
            } finally {
                loading.value = false;
            }
        };

        // Host å¤„ç†è¿å…¥
        const handleHostConnection = (conn) => {
            conns.push(conn);
            conn.on('data', (data) => {
                if (data.type === 'JOIN') {
                    // å¤„ç†é‡è¿
                    let existingRole = null;
                    if (data.savedRole && state.phase === 'PLAYING') {
                        // å¦‚æœæ¸¸æˆæ­£åœ¨è¿›è¡Œï¼Œä¸”è¯¥è§’è‰²ç›®å‰æ˜¯ Bot æˆ–æ‰çº¿çŠ¶æ€ï¼Œå…è®¸é‡è¿
                        if (gameState.players[data.savedRole] && gameState.players[data.savedRole].isBot) {
                            existingRole = data.savedRole;
                            gameState.players[existingRole].isBot = false;
                            gameState.players[existingRole].id = conn.peer;
                        }
                    }

                    if (!existingRole) {
                         // æ–°ç©å®¶
                        if (state.phase === 'WAITING') {
                            playerList.value.push({ id: conn.peer, role: null });
                            broadcastLobby();
                        } else {
                            // æ¸¸æˆä¸­æ–°ç©å®¶æ— æ³•åŠ å…¥
                            conn.send({ type: 'ERROR', msg: 'æ¸¸æˆå·²å¼€å§‹' });
                        }
                    } else {
                        // é‡è¿æˆåŠŸ
                        conn.send({ type: 'RECONNECT_SUCCESS', role: existingRole, state: gameState });
                    }
                }
                else if (data.type === 'ORDER') {
                    handleOrderReceived(data.role, data.amount);
                }
                else if (data.type === 'RECLAIM') {
                     // ç©å®¶åœ¨åŒä¸€å°ç”µè„‘é‡è¿
                     if (gameState.players[data.role]) {
                         gameState.players[data.role].isBot = false;
                         broadcastState();
                     }
                }
            });
            conn.on('close', () => {
                // ç®€å•å¤„ç†ï¼šå¦‚æœæ˜¯ç­‰å¾…é˜¶æ®µï¼Œç§»é™¤ï¼›å¦‚æœæ˜¯æ¸¸æˆé˜¶æ®µï¼Œæ ‡è®°ä¸ºBot
                const idx = playerList.value.findIndex(p => p.id === conn.peer);
                if (idx !== -1 && state.phase === 'WAITING') {
                    playerList.value.splice(idx, 1);
                    broadcastLobby();
                } else if (state.phase === 'PLAYING') {
                    // æ‰¾åˆ°å¯¹åº”çš„è§’è‰²ï¼Œè½¬ä¸º Bot
                    for (let r in gameState.players) {
                        if (gameState.players[r].id === conn.peer) {
                            gameState.players[r].isBot = true;
                        }
                    }
                }
            });
        };

        // Client å¤„ç†æ•°æ®
        const handleClientData = (data) => {
            if (data.type === 'LOBBY_UPDATE') {
                playerList.value = data.players;
            } else if (data.type === 'GAME_START') {
                myRole.value = data.role;
                Object.assign(gameState, data.state);
                state.phase = 'PLAYING';
                // ä¿å­˜è§’è‰²ä»¥ä¾¿é‡è¿
                localStorage.setItem(`bg_role_${roomCode.value}`, myRole.value);
            } else if (data.type === 'STATE_UPDATE') {
                Object.assign(gameState, data.state);
                // é‡ç½®æ¯è½®çŠ¶æ€
                hasSubmitted.value = false;
                inputOrder.value = 0;
            } else if (data.type === 'TIMER_UPDATE') {
                timer.value = data.time;
            } else if (data.type === 'GAME_OVER') {
                Object.assign(gameState, data.state);
                state.phase = 'ENDED';
                nextTick(renderCharts);
            } else if (data.type === 'RECONNECT_SUCCESS') {
                myRole.value = data.role;
                Object.assign(gameState, data.state);
                state.phase = 'PLAYING';
                imDead.value = false;
            }
        };

        const broadcastLobby = () => {
            const data = { type: 'LOBBY_UPDATE', players: playerList.value };
            conns.forEach(c => c.send(data));
        };

        const broadcastState = () => {
            // è¿‡æ»¤æ•æ„Ÿä¿¡æ¯? 
            // ä¸ºäº†ç®€åŒ–ä»£ç ï¼Œè¿™é‡Œå‘é€å®Œæ•´çŠ¶æ€ï¼Œåœ¨ Client ç«¯æ ¹æ® isOpenInfo è¿›è¡Œæ˜¾ç¤ºè¿‡æ»¤
            // å®é™…ä¸Šä¸ºäº†é˜²ä½œå¼Šåº”è¯¥åœ¨ Server ç«¯è¿‡æ»¤ï¼Œä½†è¿™é‡Œæ˜¯ä¿¡ä»»ç¯å¢ƒçš„æ•™å­¦æ¸¸æˆ
            const data = { type: 'STATE_UPDATE', state: gameState };
            conns.forEach(c => c.send(data));
            // ä¹Ÿè¦æ›´æ–° Host è‡ªå·±çš„è§†å›¾
        };

        // --- æ¸¸æˆé€»è¾‘ (Hostæ‰§è¡Œ) ---

        const startGame = () => {
            // 1. åˆ†é…è§’è‰²
            const shuffledRoles = [...ROLES].sort(() => 0.5 - Math.random());
            const playersMap = {};
            
            // å¡«å……ç©å®¶
            playerList.value.forEach((p, i) => {
                if (i < 4) {
                    p.role = shuffledRoles[i];
                }
            });

            // å¡«å……å‰©ä½™ä¸º Bot
            for (let i = 0; i < 4; i++) {
                const role = shuffledRoles[i];
                const player = playerList.value.find(p => p.role === role);
                playersMap[role] = {
                    id: player ? player.id : 'BOT',
                    isBot: !player, // å¦‚æœæ²¡ç©å®¶å°±æ˜¯Botï¼Œæˆ–è€…Hostè‡ªå·±å¦‚æœæ²¡åˆ†é…åˆ°? Hostè‚¯å®šåœ¨playerListé‡Œ
                    role: role,
                    inventory: INITIAL_INV,
                    backlog: 0,
                    lastOrder: 4, // åˆå§‹å‡è®¾
                    incomingShipment: 0,
                    history: []
                };
                // Host è‡ªå·±å¦‚æœæ˜¯ç©å®¶ï¼Œè®°å½•ä¸€ä¸‹
                if (player && player.id === 'HOST') {
                    myRole.value = role;
                }
            }
            
            // 2. åˆå§‹åŒ–çŠ¶æ€
            gameState.players = playersMap;
            gameState.week = 1;
            gameState.orderStatus = {};
            
            // 3. é€šçŸ¥æ‰€æœ‰äºº
            conns.forEach(c => {
                const p = playerList.value.find(pl => pl.id === c.peer);
                if (p && p.role) {
                    c.send({ type: 'GAME_START', role: p.role, state: gameState });
                }
            });
            state.phase = 'PLAYING';

            // 4. å¯åŠ¨è®¡æ—¶å™¨
            startTimer();
        };

        const startTimer = () => {
            timer.value = ROUND_TIME;
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timer.value--;
                if (isHost.value) {
                    conns.forEach(c => c.send({ type: 'TIMER_UPDATE', time: timer.value }));
                }
                if (timer.value <= 0) {
                    clearInterval(timerInterval);
                    if (isHost.value) processRound();
                }
            }, 1000);
        };

        const getDemand = (week) => {
            // ç»å…¸ Beer Game éœ€æ±‚: å‰4å‘¨4ä¸ªï¼Œç¬¬5å‘¨å¼€å§‹8ä¸ª
            if (week <= 4) return 4;
            return 8;
        };

        const handleOrderReceived = (role, amount) => {
            if (!isHost.value) return;
            gameState.orderStatus[role] = amount;
            // å¦‚æœæ‰€æœ‰äººç±»ç©å®¶éƒ½æäº¤äº† (Botä¸ç®—)ï¼Œå¯ä»¥æå‰ç»“æŸ
            const allHumansSubmitted = ROLES.every(r => {
                const p = gameState.players[r];
                return p.isBot || gameState.orderStatus[r] !== undefined;
            });
            
            if (allHumansSubmitted) {
                // ç­‰å¾…ä¸€ä¸‹ä»¥é˜²Botæ²¡è·‘å®Œ? ä¸éœ€è¦ï¼ŒBotæ˜¯ç¬æ—¶çš„
                // ä¸ºäº†ä½“éªŒï¼Œè¿˜æ˜¯ç­‰æ—¶é—´æˆ–è€…ç»™ä¸ªå¿«é€Ÿè·³è¿‡
            }
        };

        // æäº¤è®¢å• (Client -> Host)
        const submitOrder = () => {
            if (inputOrder.value < 0) return;
            hasSubmitted.value = true;
            myOrderVal.value = inputOrder.value;
            
            if (isHost.value) {
                handleOrderReceived(myRole.value, inputOrder.value);
            } else {
                hostConn.send({ type: 'ORDER', role: myRole.value, amount: inputOrder.value });
            }
        };

        const reconnectControl = () => {
             imDead.value = false;
             if (!isHost.value) {
                 hostConn.send({ type: 'RECLAIM', role: myRole.value });
             } else {
                 gameState.players[myRole.value].isBot = false;
             }
        };

        // æ ¸å¿ƒå›åˆç»“ç®— (Host Only)
        const processRound = () => {
            const currentWeek = gameState.week;
            
            // 1. è·å–å„ä¸ªç¯èŠ‚çš„å†³ç­– (æ²¡æœ‰æäº¤çš„ç”¨ä¸Šä¸€è½®, Bot è‡ªåŠ¨è®¡ç®—)
            const orders = {};
            
            ROLES.forEach(role => {
                const p = gameState.players[role];
                let orderQty = 0;
                
                if (p.isBot) {
                    // Bot é€»è¾‘: ç®€å•çš„ Base Stock ç­–ç•¥
                    // ç›®æ ‡åº“å­˜ = 12. 
                    // Order = Demand + (Target - (Inv - Backlog))
                    // ç®€åŒ–ç‰ˆï¼šOrder = Incoming Demand (Pass-through) ä»¥ä¿æŒç¨³å®š
                    const incomingDemand = role === 'Retailer' ? getDemand(currentWeek) : (gameState.players[getDownstream(role)]?.lastOrder || 4);
                    // ç¨å¾®ä¿®æ­£ï¼šå¦‚æœåº“å­˜å¤ªä½è¡¥ä¸€ç‚¹
                    let correction = 0;
                    if (p.inventory < 4) correction = 2;
                    if (p.backlog > 0) correction = p.backlog;
                    orderQty = incomingDemand + correction;
                } else {
                    // ç©å®¶é€»è¾‘
                    if (gameState.orderStatus[role] !== undefined) {
                        orderQty = gameState.orderStatus[role];
                    } else {
                        orderQty = p.lastOrder; // è¶…æ—¶æ²¿ç”¨
                    }
                }
                orders[role] = orderQty;
                p.lastOrder = orderQty; // æ›´æ–°ç”¨äºä¸‹è½®å‚è€ƒ
            });

            // 2. ä¾›åº”é“¾æµåŠ¨é€»è¾‘ (ç®€åŒ–ç‰ˆï¼šæ— è¿è¾“å»¶è¿Ÿï¼Œè®¢å•æœ‰å»¶è¿Ÿæ•ˆæœ)
            // é¡ºåºï¼šæ”¶è´§ -> æ»¡è¶³éœ€æ±‚ -> è®°å½• Backlog -> å‘å‡ºè®¢å•
            
            // è¿™é‡Œçš„ "Incoming Shipment" å…¶å®æ˜¯ä¸Šæ¸¸ *ä¸Šä¸€è½®* å‘å‡ºçš„è´§ (æˆ–è€…æœ¬è½®å¦‚æœæœ‰å»¶è¿Ÿ)
            // ç»å…¸æ¸¸æˆï¼š2å‘¨å»¶è¿Ÿã€‚è¿™é‡Œä¸ºäº†å•é¡µ Web ä½“éªŒï¼Œç®€åŒ–ä¸ºï¼š
            // Factory ç”Ÿäº§æ— é™åˆ¶ï¼Œç›´æ¥å‘è´§ã€‚
            // å…¶ä»–è§’è‰²ï¼šæ”¶åˆ°çš„è´§æ˜¯ä¸Šæ¸¸ *æœ¬è½®* èƒ½å‘å‡ºçš„é‡ (ç¬æ—¶) æˆ–è€… *ä¸Šä¸€è½®* å‘å‡ºçš„ (å»¶è¿Ÿ)ã€‚
            // é‡‡ç”¨ï¼šä¸Šæ¸¸å‘è´§ -> ä¸‹æ¸¸ä¸‹è½®æ”¶åˆ° (1å‘¨å»¶è¿Ÿ)
            
            // å…ˆè®¡ç®—æœ¬è½®æ¯ä¸ªèŠ‚ç‚¹èƒ½å‘å¤šå°‘è´§ (Shipment Sent)
            const shipmentsSent = {}; // Key: Role, Val: Amount
            
            ROLES.slice().reverse().forEach(role => {
                const p = gameState.players[role];
                
                // ç¡®å®šè¯¥è§’è‰²çš„éœ€æ±‚æ¥æº
                let currentDemand = 0;
                if (role === 'Retailer') {
                    currentDemand = getDemand(currentWeek);
                } else {
                    // ä¸‹æ¸¸ä¸Šå‘¨ä¸‹çš„è®¢å•
                    const downstream = getDownstream(role);
                    currentDemand = gameState.players[downstream].lastOrder;
                }

                // æ€»éœ€æ±‚ = æ–°è®¢å• + ç§¯å‹è®¢å•
                const totalDemand = currentDemand + p.backlog;
                
                // å¯ç”¨åº“å­˜ = æœŸåˆåº“å­˜ + æœ¬å‘¨æ”¶åˆ°çš„è´§
                // æ³¨æ„ï¼šæœ¬å‘¨æ”¶åˆ°çš„è´§æ˜¯ä¸Šæ¸¸ *ä¸Šä¸€å‘¨* å‘å‡ºçš„
                // æˆ‘ä»¬éœ€è¦åœ¨ State é‡Œå­˜ä¸€ä¸ª "incomingShipment" é˜Ÿåˆ—
                // ç®€åŒ–ï¼šä½¿ç”¨ state.shipments æŸ¥æ‰¾ to === role çš„
                const incoming = state.shipments.find(s => s.to === role && s.weeksLeft === 0);
                const arrivedQty = incoming ? incoming.amount : 0;
                
                p.incomingShipment = arrivedQty; // ç”¨äºUIæ˜¾ç¤ºæœ¬å‘¨åˆ°è´§
                const available = p.inventory + arrivedQty;
                
                // å‘è´§é€»è¾‘
                let shipped = 0;
                if (available >= totalDemand) {
                    shipped = totalDemand;
                    p.inventory = available - totalDemand;
                    p.backlog = 0;
                } else {
                    shipped = available;
                    p.inventory = 0;
                    p.backlog = totalDemand - available;
                }
                
                shipmentsSent[role] = shipped;

                // è®°å½•å†å²
                p.history.push({
                    week: currentWeek,
                    inventory: p.inventory,
                    backlog: p.backlog,
                    order: orders[role],
                    demand: currentDemand,
                    cost: p.inventory * 0.5 + p.backlog * 1 // å‡è®¾åº“å­˜æˆæœ¬0.5, ç¼ºè´§æˆæœ¬1
                });
            });

            // 3. å¤„ç†å‘è´§äº§ç”Ÿçš„ç‰©æµ (è¿›å…¥ä¸‹å‘¨çš„ Incoming)
            // æ¸…ç†æ—§çš„å·²åˆ°è´§ç‰©æµ
            gameState.shipments = state.shipments.filter(s => s.weeksLeft > 0);
            gameState.shipments.forEach(s => s.weeksLeft--);

            // äº§ç”Ÿæ–°ç‰©æµ
            ROLES.forEach(role => {
                const amount = shipmentsSent[role];
                if (role === 'Factory') {
                    // Factory ç”Ÿäº§æ— é™ï¼Œå‘ç»™ Distributor
                    gameState.shipments.push({ to: 'Distributor', amount: amount, weeksLeft: 1 }); // 1å‘¨å»¶è¿Ÿ
                    // Factory è‡ªå·±ä¹Ÿéœ€è¦è¿›è´§(åŸææ–™)ï¼Œå‡è®¾æ— é™ä¸”æœ‰å»¶è¿Ÿ
                    gameState.shipments.push({ to: 'Factory', amount: orders['Factory'], weeksLeft: 1 });
                } else if (role !== 'Retailer') {
                    // å‘ç»™ä¸‹æ¸¸
                    const downstream = getDownstream(role);
                    gameState.shipments.push({ to: downstream, amount: amount, weeksLeft: 1 });
                } else {
                    // Retailer å‘ç»™é¡¾å®¢ (æ¶ˆå¤±)
                }
            });

            // 4. è¿›å…¥ä¸‹ä¸€å‘¨
            gameState.week++;
            gameState.orderStatus = {}; // é‡ç½®æäº¤çŠ¶æ€

            if (gameState.week > TOTAL_WEEKS) {
                endGame();
            } else {
                broadcastState();
                startTimer();
            }
        };

        const getDownstream = (role) => {
            const idx = ROLES.indexOf(role);
            if (idx > 0) return ROLES[idx - 1];
            return null; // Customer
        };

        const endGame = () => {
            state.phase = 'ENDED';
            conns.forEach(c => c.send({ type: 'GAME_OVER', state: gameState }));
            nextTick(renderCharts);
        };

        // --- è¾…åŠ©åŠŸèƒ½ ---
        const canSee = (role) => {
            if (gameState.isOpenInfo) return true;
            if (role === myRole.value) return true;
            return false;
        };

        const getIncomingDemand = (role) => {
            if (state.phase !== 'PLAYING') return 0;
            if (role === 'Retailer') return getDemand(gameState.week);
            const down = getDownstream(role);
            // å°é—­æ¨¡å¼ä¸‹ï¼Œä½ çœ‹ä¸åˆ°ä¸‹æ¸¸è¿™å‘¨å…·ä½“çš„å•å­ï¼Œç›´åˆ°ç»“ç®—ï¼Ÿ
            // ç»å…¸ç©æ³•æ˜¯ï¼šä½ æ”¶åˆ°ä¸€ä¸ªä¿¡å°ã€‚
            // ç®€åŒ–ï¼šæ˜¾ç¤ºä¸Šå‘¨ä¸‹æ¸¸çš„è®¢å•ä½œä¸ºå‚è€ƒï¼Œæˆ–è€…å®æ—¶æ˜¾ç¤ºï¼ˆå¦‚æœæ˜¯é€æ˜æ¨¡å¼ï¼‰
            if (gameState.isOpenInfo) return gameState.players[down].lastOrder;
            // å°é—­æ¨¡å¼ï¼šæ˜¾ç¤ºä¸Šå‘¨çš„
            return gameState.players[down]?.lastOrder || 0;
        };

        // --- å›¾è¡¨ ---
        const renderCharts = () => {
            const ctxOrder = document.getElementById('orderChart');
            const ctxCost = document.getElementById('costChart');
            if (!ctxOrder || !ctxCost) return;

            const weeks = Array.from({length: TOTAL_WEEKS}, (_, i) => i + 1);
            const datasetsOrder = ROLES.map((role, i) => {
                const color = ['#e74c3c', '#3498db', '#f1c40f', '#2ecc71'][i];
                return {
                    label: roleNames.value[role],
                    data: gameState.players[role].history.map(h => h.order),
                    borderColor: color,
                    fill: false
                };
            });

            // å¢åŠ  Demand çº¿
            datasetsOrder.push({
                label: 'å®é™…å¸‚åœºéœ€æ±‚',
                data: weeks.map(w => getDemand(w)),
                borderColor: '#000',
                borderDash: [5, 5],
                fill: false
            });

            const datasetsCost = ROLES.map((role, i) => {
                const color = ['#e74c3c', '#3498db', '#f1c40f', '#2ecc71'][i];
                return {
                    label: roleNames.value[role] + ' ç´¯è®¡æˆæœ¬',
                    data: gameState.players[role].history.reduce((acc, curr, idx) => {
                        const prev = idx > 0 ? acc[idx-1] : 0;
                        acc.push(prev + curr.cost);
                        return acc;
                    }, []),
                    borderColor: color,
                    fill: false
                };
            });

            new Chart(ctxOrder, {
                type: 'line',
                data: { labels: weeks, datasets: datasetsOrder },
                options: { responsive: true, title: { display: true, text: 'è®¢è´§é‡å˜åŒ– (ç‰›é­æ•ˆåº”)' } }
            });

            new Chart(ctxCost, {
                type: 'line',
                data: { labels: weeks, datasets: datasetsCost },
                options: { responsive: true, title: { display: true, text: 'ç´¯è®¡æˆæœ¬' } }
            });
        };
        
        const downloadData = () => {
            let csv = "Week,Role,Inventory,Backlog,Order,Cost\n";
            ROLES.forEach(role => {
                gameState.players[role].history.forEach(h => {
                    csv += `${h.week},${role},${h.inventory},${h.backlog},${h.order},${h.cost}\n`;
                });
            });
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `beergame_results_${roomCode.value}.csv`;
            a.click();
        };

        return {
            state, roomCode, myId, isHost, loading, error, playerList, myRole, timer, gameState,
            inputOrder, hasSubmitted, myOrderVal, imDead,
            rolesOrder, roleNames, connectedPlayers, myRoleLabel,
            createRoom, joinRoom, startGame, submitOrder, reconnectControl, canSee, getIncomingDemand,
            downloadData
        };
    }
}).mount('#app');
</script>
</body>
</html>